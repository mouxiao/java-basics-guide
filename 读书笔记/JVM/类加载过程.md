## **类加载过程**
> 类加载主要分为三步:加载,链接,初始化。

![avatar](类加载.png)

下面，我们将逐步对这三部分进行了解：
### **加载**
> 第一步"加载"，细分的话，大致也分为三步：
- 通过全类名(本地java文件编译后的class文件, zip/jar包里的class文件,以及通过网络加载的class文件)获取定义该类的二进制字节流
- 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
- 在内存中生成一个代表该类的Class对象，作为方法区访问这些数据的入口
### **链接**
类的链接又分为验证,准备,解析三个阶段
- 验证
  - 文件格式验证：主要验证第一步被加载后的类字节流是否符合Class文件格式规范，是否能被当前虚拟机正确加载。
比如：主次版本号是否在当前虚拟机处理范围之内，常量池中是否有不被支持的常量等。
   - 元数据验证: 对字节码描述的信息进行语义分析，是否符合java规范。比如:是否有类继承了被final修饰的类或者方法
   ,是否有父类等等
   - 字节码验证: 主要验证程序语义是否合法,是否符合逻辑。
   - 符号引用验证: 确保解析动作能正确执行。
- 准备
    准备阶段主要为类的静态变量分配内存，并设置默认初始值。需要注意的是：
    - 这个阶段进行内存分配的仅仅包含被static修饰的变量。这里设置的初始值，指的是数据类型的默认值(0，0L
    ,null,false)，但是被final关键字修饰的变量在这个阶段初始值会有例外:
    ``` java
  public static int value = 144;  //初始值为0
    public static final int value1 =144; //被final修饰的初始值为144
    ```
- 解析
    解析阶段是将虚拟机常量池的符号引用替换为直接引用。
    // TODO


### **初始化**

>类加载的最后一步，在这一步会将程序的主导权从JVM移交给我们所写的java代码。在这一步会将我们在类准备阶段为静态常量分配内存设置默认值的变量
进行真正java编码的初始化。 通俗来讲这一步初始化过程，就是执行clinit()的过程。clinit()方法由javac编译器自动生成，clinit()主要由类变量的赋值和静态语句块中的语句合并产生。它的收集顺序以源文件中出现的顺序决定的。
  
>如果一个类或者接口有继承关系，Java虚拟机会先执行父类的clinit()方法，然后执行子类的clinit()方法.通俗来说，类初始化的时候会先
初始化父类，加载父类静态变量和静态代码块。然后初始化子类，加载子类的静态常量和静态代码块。接口和类在初始化时有一点区别：执行接口的clinit()方法时，如果
子接口中没有使用父接口中的变量，可以不用初始化父接口，否则需要先初始化父接口。 
        
> 需要注意的是，在虚拟机中，加载,验证,准备,初始化,卸载这五个阶段的顺序是固定的。但是《Java虚拟机规范》中规定了有且只有六种情况
必须对类进行初始化:
     
- 遇到new,getstatic,putstatic,invokestatic这四条指令时，如果类型没有进行初始化，则需要先触发其初始化阶段
    - new关键字
    - 被final修饰的静态字段
    - 调用一个类的静态方法时
- 使用java.lang.reflect包的方法对类型进行反射
- 初始化类时父类还没有初始化
- 接口中有被default关键字修饰的方法   
- 当虚拟机启动，需要指定一个执行的主类时,虚拟机会先初始化这个类,比如main()方法
- 当使用JDK7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic,REF_putStatic,REF_invokeStatic,
REF_newInvokeSpecial四种类型的句柄，并且这个方法句柄对应的类没有初始化，则需要先进行初始化。
   
### **卸载**
// TODO         
        

